# Django framework
## Общие сведения
Django - бесплатный веб-[[фреймворк]] с открытым исходным кодом, написанный на языке Python. Предназначен для работы сайтов на стороне сервера.
Пакет Django в своем составе содержит отладочный Web-сервер, который можно запустить на свой ПК и проверить работу сайта, не используя сторонний сервер.
## Установка Django
Чтобы все модули согласованно работали и выдавали ожидаемые результаты на запросы пользователей, желательно и на тестовом сервере и на реальном использовать одни и те же версии программных продуктов: начиная с выбранной версии Django и заканчивая определенной версией интерпретатора языка Python.
- создать папку
- создать проект
- выбрать виртуальное окружение
- просмотр установленных пакетов (pip list)
- установка фреймфорка в созданное виртуальное окружение
- находясь в корневой папке (pip install django)
- для создания сайта (django-admin startproject <имя сайта>)
И фреймворк создал папку <имя сайта> в рабочей папке проекта. Внутри этой папки имеется одноименная вложенная папка пакета, который определяет конфигурацию нашего сайта. Поэтому его часто так и называют – пакетом конфигурации.

Также есть еще один отдельный файл manage.py, через который и производится управление данным сайтом. Это своеобразная утилита, посредник, который передает наши команды django-admin и выполняет их «от лица» нашего сайта.
Для этого перейдем в папку <имя сайта>: cd <имя сайта>
выполнить (python manage.py runserver)

Происходит запуск локального Веб-сервера, который поставляется вместе с Django, и наш сайт должен быть доступен по адресу http://127.0.0.1:8000.
Преимущество отладочного сервера в том, что он автоматически перезапускается при изменении программы сайта. На практике это дает большое удобство. Но полностью полагаться на эту возможность не стоит, так как иногда Django все же игнорирует изменения, а точнее, новые дополнения, например, новые созданные файлы. Поэтому, если вы видите, что что-то работает не так, попробуйте просто перезапустить сервер вручную. Для его завершения достаточно нажать комбинацию клавиш: Ctrl + Break (а также Ctrl + C в Windows)

Его можно запускать также и со следующими параметрами: python manage.py runserver 4000 или так: python manage.py runserver 192.168.1.1:4000
при первом запуске сервера в проекте появился еще один файл db.sqlite3 – файл БД SQLite3. Дело в том, что по умолчанию Django использует именно такую СУБД. В дальнейшем, мы можем это изменить и указать любую другую СУБД, которую поддерживает данный фреймворк. Например PostgreSQL, MariaDB, MySQL, Oracle или SQLite.
## Модель MTV
механизм обработки запросов от пользователя
когда запрос приходит на фреймворк, он пропускается через блок маршрутизации:
![[Pasted image 20231214221805.png]]
Здесь фиксируется тип URL-адреса и в списке шаблонов предопределенных адресов ищется первое совпадение.

У нас может быть прописано множество типов URL-адресов и каждый адрес связан со своим обработчиком – представлением (иногда его еще называют контроллером). Если текущий запрос от пользователя не совпал ни с одним предопределенным URL, то возвращается код ошибки 404 – страница не найдена.

Предположим, что маршрутизатор нашел совпадение. Далее, активизируется представление, связанное с найденным типом URL-адреса. Представление (иногда его еще называют контроллером) – это или функция или класс, который отвечает за формирование ответа на соответствующий запрос. Как правило, ответом является HTML-страница. Эта страница, затем, возвращается клиенту, и он ее видит в браузере. Так вот, чтобы контроллер мог сформировать страницу, в общем случае, требуются данные (информация), плюс шаблоны, в которые эти данные упаковываются.

Такое разделение на данные (model), шаблоны (templates) и представления (views) представляет собой общеизвестный паттерн MTV, то есть, разделение данных и HTMLшаблонов.
![[Pasted image 20231214222236.png]]
Техника довольно эффективна и удобна, так как позволяет независимо наполнять БД информацией и параллельно разрабатывать или изменять функционал сайта. Кроме того здесь легче находить ошибки, в отличие от подхода, когда в одном скрипте присутствует и подключение к БД и оперирование шаблонами. Методика «разделяй и властвуй» очень хорошо себя зарекомендовала в мире программирования и довольно часто используется в том или ином виде.
## Добавление первого приложения
Разработчики фреймворка решили, что каждая самостоятельная часть сайта должна представляться в виде своего отдельного приложения. Приложения в Django следует реализовывать максимально независимыми, в идеале – полностью независимыми, чтобы в дальнейшем мы могли их просто скопировать в другой сайт и там оно сразу же начинало бы работать. Это не всегда удается, но нужно к этому стремиться.

создадим в нашем сайте первое приложение, которое возьмет на себя базовый функционал, то есть, оно и будет являться ядром нашего сайта. Для этого в терминале, находясь в корневом каталоге нашего проекта, выполним команду: python manage.py startapp <название>
После выполнения команды у нас в проекте появилась еще одна папка, которая уже содержит несколько файлов и файл __init__.py, следовательно, приложение в Django реализуется как пакет языка Python. Также здесь присутствует одна вложенная папка migrations для хранения миграций БД нашего приложения.

Остальные файлы имеют следующее назначение: admin.py – для настройки админ-панели сайта (админ-панель поставляется совместно с Django и каждый сайт может сразу ее использовать); apps.py – для настройки (конфигурирования) текущего приложения; models.py – для хранения ORM-моделей для представления данных из базы данных; tests.py – модуль с тестирующими процедурами; views.py – для хранения представлений (контроллеров) текущего приложения.

После создания приложения его необходимо зарегистрировать в проекте нашего сайта, чтобы фреймворк Django «знал» о его существовании и корректно с ним работал. Для этого нужно перейти в пакет конфигурации сайта, открыть файл settings.py и в списке INSTALLED_APPS прописать новое приложение. В нем уже прописаны несколько стандартных приложений самого фреймворка и к ним мы просто добавим свое:
![[Pasted image 20231214223525.png]]
По идее этого вполне достаточно и все будет работать, но в действительности Django обращаясь к этому пакету находит файл apps.py, откуда и берет настройки приложения из класса StudentsConfig. Чтобы в дальнейшем каждый раз не конкретизировать этот путь, пропишем его сразу в списке приложений:
![[Pasted image 20231214223600.png]]

Для дальнейшей работы укажем рабочим каталогом проект
Для этого кликнем правой кнопкой мыши на имени нашего проекта и пометим наш каталог как Source Root. После этого цвет папки с каталогом изменится на синий.
![[Pasted image 20231214223632.png]]

## Представления и маршрутизация
приложение создано и зарегистрировано. Давайте теперь создадим обработчик главной страницы сайта. Для этого нужно определить представление этой страницы. Все представления мы располагаем в файле views.py конкретного приложения.

представления в Django можно реализовывать или в виде функций или в виде классов. Давайте для начала воспользуемся функцией, как наиболее простой реализацией для понимания. Эта функция будет отвечать за формирование ответа для главной страницы приложения students и называться index (название может быть любым, мы его определяем сами). Не забудем также импортировать вверху файла функцию HttpResponse:

```python 
from django.http import HttpResponse 
def index(request): return HttpResponse("Страница приложения students.")
```

Здесь указывается первый обязательный параметр request – это ссылка на экземпляр класса HttpRequest, который содержит информацию о запросе, о сессии, о куках и так далее. То есть, через переменную request нам доступна вся возможная информация в рамках текущего запроса. На выходе эта функция должна возвращать экземпляр объекта HttpResponse, который будет автоматически формировать нужный заголовок ответа, а содержимое HTML-страницы будет определяться указанной строкой.

![[Pasted image 20231214224006.png]]
Теперь нам нужно связать эту функцию представления главной страницы с соответствующим URL-адресом. Для этого в пакете конфигурации откроем файл urls.py и в список адресов urlpatterns добавим новый путь с помощью специальной функции path:
```python 
urlpatterns = [ 
			   path('admin/', admin.site.urls), 
			   path('students/', index), 
			   ]
```
Здесь первый параметр – это суффикс URL-адреса, то есть, часть URL, которая добавляется после доменного имени (при этом в конце ставится слеш). Например, если наш сайт располагается по адресу http://127.0.0.1:8000 то первый аргумент students/ добавляется в конце к этому пути: http://127.0.0.1:8000/students/

Второй аргумент – это ссылка на функцию представления, которая должна возвращать ответ на данный запрос. Как мы уже знаем, ответ формируется в виде экземпляра класса HttpResponse. Теперь нам нужно импортировать функцию index, чтобы она была доступна в пакете конфигурации:
```python
from students.views import index
```

В рамках этого приложения мы можем определять сколько угодно таких функций, связанных с разными URL-адресами. Например, пропишем еще одну функцию отображения списка студентов по группам:
```python
def groups(request):
 return HttpResponse("<h1>Список студентов по группам.</h1>")
```

Затем, добавляем еще один путь в список urlpatterns:
```python
path('groups/', groups),
```

как только мы добавили дополнительные маршруты, тестовая главная страница перестала выдаваться, вместо этого мы видим исключение 404 – страница не найдена. Чтобы задать маршрут для главной страницы, можно вместо «students/» записать пустую строку:
```python
from students.views import index, groups
urlpatterns = [
 path('admin/', admin.site.urls),
 path('', index),
 path('groups/', groups),
]
```
Здесь пустая строка как раз и соответствует маршруту главной страницы и теперь при обращении к ней будет вызываться функция представления index.

Однако такой подход, когда мы маршруты приложения прописываем в пакете конфигурации, нарушает принцип независимости приложений.

Как это можно разрешить? Очень просто

Django позволяет вторым параметром вместо функции представления передавать список URL-адресов приложения и связанные с ними функции. Для этого мы сначала импортируем специальную функцию include:
```python
from django.urls import path, include

urlpatterns = [
 path('admin/', admin.site.urls),
 path('students/', include('students.urls')),
]

```

Мы добавляем в приложение students новый файл urls.py и в нем формируем список urlpatterns:
```python
from django.urls import path
from .views import index, groups
urlpatterns = [
 path('', index),
 path('groups/', groups),
]
```
Здесь мы, во-первых, импортируем функцию path, которая и связывает URL c функциями представления и, во-вторых, импортируем функции из модуля views текущего пакета. Далее, в списке urlpatterns вызываем функцию path, первым параметром указываем пустую строку, а вторым функцию index.

## Определение моделей
## Создание и запуск миграций приложения
## CRUD - основы ORM по работе с моделями
## Менеджер записей objects
### Выборка записей из таблицы
### Сортировка записей 
### Изменение записей 
### Удаление записей 
## Работа с шаблонами
### Шаблоны(Templates). Основы
### Передача шаблонам параметров
### Создание базового шаблона (наследование шаблонов)
### Подключение статических файлов
### Фильтры шаблонов
### Формирование URL-адресов в шаблонах

## Создание связей между моделями через класс ForeignKey
## Работа с Админ-панелью
## Добавляем слаги (slug) к URL-адресам
### Отображение записей по идентификатору (id)
### Добавление слага
### Отображение записей по слагу (slug)
## Формы
### Формы, не связанные с моделями
### Формы, связанные с моделями
### Загрузка изображений через форму
### Создание собственных валидаторов формы
## Классы представлений
### Классы представлений (контроллеры классов)
### Класс представлений ListView
### Класс представлений DetailView
### Класс представлений CreateView
## Миксины (Mixins)
### Использование миксинов

## Постраничная навигация (пагинация)
## Аутентификация
### Регистрация пользователей на сайте
### Авторизация пользователей на сайте