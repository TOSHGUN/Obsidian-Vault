# Язык программирования C sharp
С# — это полнофункциональный объектно-ориентированный язык, который поддерживает все три «столпа» объектно-ориентированного программирования: инкапсуляцию, наследование и полиморфизм. С# похож на язык Java в том отношении, что он требует, чтобы вся программная логика была заключена в определения типов (под типом подразумеваются классы, интерфейсы, структуры и аналогичные компоненты языка), т.е. является полностью объектно-ориентированным.  В отличие от С и C++ глобальные функции и глобальные переменные в чистом виде в С# недопустимы, все определения могут быть выполнены только внутри классов, структур, интерфейсов. С# генерирует код, предназначенный для выполнения только в среде выполнения .NET.

# Платформа .NET
**.NET** следует рассматривать как новую среду выполнения и новую библиотеку базовых классов. .NET предоставляет:
- полное и абсолютное межъязыковое взаимодействие; .NET поддерживает межъязыковое наследование, межъязыковую обработку исключений, межъязыковую отладку;
- общую среду выполнения всех приложений .NET, не зависимо от того, на каких языках они были написаны;
- библиотеку базовых классов, которая обеспечивает сокрытие всех сложностей, связанных с использованием непосредственно API, и предлагает целостную объектную модель для всех языков программирования.

# Среда выполнения
**Среда выполнения** .NET – Common Language Runtime (CLR) – выполняет следующие функции:
- обнаруживает и загружает типы .NET;
- производит управление объектами;
- выполняет низкоуровневые операции: автоматическое управление памятью, межъязыковое взаимодействие, развертывание двоичных библиотек.

Первый компонент – это ядро среды выполнения, которое реализовано в виде библиотеки mscoree.dll, которая автоматически загружается в память при обращении к приложению .NET. Эта библиотека в свою очередь управляет процессом загрузки в память сборки данного приложения. Согласно терминологии Microsoft **код, предназначенный для работы в среде выполнения .NET, — это управляемый код** (managed code). **Сборкой** (assembly) называется **двоичный файл, который содержит управляемый код.**

Второй компонент – это библиотека базовых классов. Сама библиотека разбита на множество отдельных сборок, главная сборка библиотеки базовых классов представлена файлом mscorlib.dll. Библиотека содержит множество типов для решения задач при создании приложения.

**Стандартная система типов – Common Type System (CTS)** полностью описывает все типы данных, поддерживаемые средой выполнения (CLR), определяет, как одни типы данных могут взаимодействовать с другими. Стандартная система типов – это формальная спецификация, которая определяет, как какой-либо тип должен быть определен для правильного восприятия средой выполнения .NET.

Однако не все языки .NET поддерживают все типы, определенные в CTS. **Подмножество общих типов данных**, доступных во всех языках .NET, определяется правилами **Common Language Specification (CLS).**

**Библиотека базовых классов** .NET  доступна из любого языка программирования .NET.

Двоичные файлы .NET, для которых используются стандартные разрешения DLL и EXE, по своему внутреннему содержанию не имеют ничего общего с обычными исполняемыми файлами. Двоичные файлы .NET не содержат зависящих от платформы команд. Содержимое двоичных файлов .NET – это платформенно-независимый промежуточный язык, который официально называется Microsoft Intermediate Language (MSIL) – промежуточный язык Microsoft, или просто IL.

Когда с помощью компилятора для платформы .NET создается модуль DLL или EXE, содержимое этого файла – сборка на языке IL, которая в дальнейшем компилируется в платформенно-специфичные инструкции компилятором времени выполнения – “just-in-time compiler” (JIT). Компилятор входит в состав среды выполнения .NET. Компиляция осуществляется, когда к блоку инструкций IL обращается для использования среда выполнения .NET. Откомпилированные из IL платформенно-зависимые инструкции JIT размещает в кеш-памяти. При повторных вызовах откомпилированных ранее программных блоков компиляция не производится, а берется готовый код из Кеша в оперативной памяти, что значительно ускоряет работу приложения.

Двоичные модули .NET содержат также метаданные, которые подробно описывают все типы, использованные в модуле. Метаданные для каждого класса содержат полное описание всех методов, свойств и событий класса, а также информацию о базовых классах и интерфейсах. Метаданные автоматически генерируются компилятором, создающим приложение .NET. Метаданные описывают не только типы, используемые в сборке, но и саму сборку. В них перечислены все ссылки на внешние модули и сборки, которые потребуются для нормального выполнения сборки .NET. Эта часть метаданных называется манифестом (manifest). Метаданные используются средой выполнения .NET, средствами разработки и отладки, утилитами просмотра и компилятором С#.

Сборка может состоять как из одного, так и из нескольких двоичных файлов. В сборке из одного файла этот единственный файл содержит и манифест, и метаданные, и инструкции IL. В сборке из нескольких двоичных файлов (модулей) один из них должен содержать манифест сборки, остальные – только метаданные типов и инструкции IL.

Код IL не зависит от платформы, на которой будет производиться выполнение. Поскольку любой код на любом языке программирования .NET компилируется в стандартный набор инструкций IL, проблем во взаимодействии между блоками кода IL не возникает.

При условии распространения платформы .NET на разные компьютерные платформы и операционные системы появится возможность создавать приложения на любом языке, которые будут работать на любой платформе и под любой операционной системой. Пока же приложения .NET могут работать только под Windows.

# Некоторые отличия C sharp от C++

Язык программирования C# основан на синтаксических конструкциях С++, однако существуют отличия.
1. Переключатель switch
	Обеспечивает выбор только одной ветви из множества взаимоисключающих ветвей,  поэтому каждая ветвь case должна заканчиваться словом break, а фигурные скобки можно опускать, т.к. программный блок ограничен словами case и break.
2. Цикл foreach
	Позволяет последовательно обрабатывать все элементы массива, не изменяя их значения. Синтаксис оператора:
	```
	foreach ( тип_элемента buffer in имя_массива)
	  {
			операторы_тела_цикла`
	  }
	```
	Кроме обработки элементов простых массивов, цикл foreach можно использовать для обработки встроенных и пользовательских коллекций.
 3. Массивы
	Все массивы – ссылочные типы и следуют семантике ссылок, т.е. имя массива – это указатель, а все массивы являются динамическими, синтаксис описания одномерного массива:
	`тип_элемента [] имя_массива;`
	Для выделения памяти под массив определенного размера используется операция new:
	`имя_массива = new тип_элемента [количество_элементов];`
	до выделения памяти переменная имя массива является null-ссылкой.
	Память может быть выделена непосредственно при описании массива, тогда же массив может быть инициализирован. С# допускает укороченную запись определения и инициализации массива:
	`тип_элемента [] имя_массива = {список_инициализирующих_значений};`
	Многомерные массивы объявляются с помощью включения запятых между квадратными скобками: одной – для двумерного массива, двух – для трехмерного и т.д.
	
	Объявление массива с квадратными скобками – это нотация C#, использующая абстрактный класс Array. Объявление массива приводит к созданию нового класса, унаследованного от базового класса Array.Таким образом, методы и свойства класса Array доступны любому массиву C#:
	
	- свойство Length (LongLength) возвращает количество элементов в массиве – значение типа int (long int), для многомерных массивов возвращает количество элементов по всем измерениям;
	- свойство Rank возвращает количество измерений массива;
	- статический метод 
	`public static Array CreateInstance ( Type elementType, int length)`
	позволяет создать массив во время выполнения программы, если заранее тип элементов не известен. Тип передается через первый параметр, второй параметр задает размер массива. Тип элемента можно передать с помощью функции typeof(тип) или метода GetType() базового класса Object.
	- метод SetValue() позволяет задать значение элементу массива;
	- метод GetValue() позволяет получить значение элемента массива;
	- методы Clone() и Copy() позволяют создавать копию массива: Clone() сам создает новый массив, Copy() требует наличия существующего массива той же размерности с достаточным количеством элементов;
	- метод Sort() реализует пузырьковую сортировку элементов массива, если элементами массива являются объекты собственных классов, то они должны реализовывать интерфейс IComparable, который определяет единственный метод CompareTo();
	- метод Clear() очищает элементы массива;
	- методы Contains() и IndexOf() выполняют линейный поиск элемента в массиве, первый возвращает логическое значение, второй – индекс первого найденного элемента.
3. Операции
	- checked и unchecked позволяют включать и выключать проверку выхода значений за допустимый диапазон;
	- is позволяет проверить, совместим  ли объект с определенным типом, возвращает логическое значение;
	- as применяется для явного преобразования типа ссылочных переменных, если типы не совместимы, операция as возвращает null;
	- sizeof(тип) определяет размер памяти в байтах, необходимый для размещения значения указанного типа, не применима к классам, может использоваться только в unsafe-коде;
	- typeof возвращает объект типа System.Type, представляющий указанный тип;
	
4. Типы
	- decimal – 128-битное значение с плавающей запятой в десятичной нотации, 28 знаков, диапазон: ±1*10-28 ÷ ±7,9*1028; используется для представления чисел с плавающей запятой высокой точности (финансовые операции);
	- bool – логическое значение true или false, не допускается неявное преобразование bool в целые и обратно;
	- object – базовый родительский тип, от которого наследуются все внутренние и пользовательские типы, object реализует множество базовых методов общего назначения, используется для реализации полиморфизма;
	- string предназначен для работы со строками, фактически преобразуется в класс .NET System.String, это ссылочный тип, объекты размещаются в куче.
	- в программах на С# как правило не используются указатели;
	- управление памятью производится автоматически.
	
5. Пространство имен
	Пространства имен предоставляют возможность организации взаимосвязанных классов и других типов. Пространство имен представляет собой скорее логическое, а не физическое понятие. В C# принято каждый класс определять в отдельном файле. Для объединения взаимосвязанных классов и используется пространство имен. Синтаксис определения пространства имен:
	```
	namespace имя_пространства
		{
		определения типов
		}
	```
	Полное имя типа в этом случае имеет вид:
	   имя_пространства.имя_типа
	
	Это позволяет использовать в одной программе различные классы с одинаковыми именами, определенные в различных пространствах.
	
	Пространства имен можно вкладывать друг в друга, тогда полное имя будет дополняться именами всех пространств имен, начиная с верхнего. Имена пространств также разделяются точками. Составные имена можно использовать и в самом определении имени пространства, однако составное имя пространства нельзя при определении вкладывать в другое пространство.

Чтобы избежать в программе использования полных имен типов, достаточно в начале файла указать используемые пространства имен, дополнив каждое имя словом using:

using имя_пространства;

в этом случае допустимо использование для несовпадающих имен их коротких вариантов.

Если полное имя пространства достаточно длинное, а его приходится использовать в программе, можно в предложении using назначить ему псевдоним:

using псевдоним = имя_пространства_ имен;

тогда в программе можно использовать псевдоним с квалификатором «::»:

псевдоним::имя_типа

Такое написание позволяет избежать двусмысленности при совпадении псевдонима с каким-либо именем, объявленном в этом же файле.


1. Метод Main
	Программы на C# начинают выполняться с метода по имени Main(), поэтому один из классов обязательно должен иметь метод Main(), этот метод должен быть статическим с типом возвращаемого результата void или int. Именно с этого метода начинается выполнение программы.
2. Соглашения об именах в C#
	В именах не принято для разделения слов использовать символ подчеркивания, но каждое слове в имени принято писать с заглавной буквы (Pascal casing), имена констант подчиняются этому же правилу.
	Однако для параметров, передаваемых методам, и private полей-членов класса используется Camel casing – первая буква в имени является строчной (имена полей иногда начинаются с символа подчеркивания). Такое соглашение принято, чтобы избежать совпадения  имен полей и свойств, а также обеспечить единообразие при использовании имен в других классах: там должны быть видны имена, написанные только в стиле Pascal casing. Кроме того при использовании вашего кода в средах, не чувствительных к регистру, также не вызовет противоречий, т. к. private члены там не доступны.
# Классы

Класс определяет, какие данные и какую функциональность может иметь каждый конкретный объект данного класса. Классы – это ссылочные типы, размещаемые в куче, т.е. имя любого объекта рассматривается системой как указатель, поэтому объект всегда создается с помощью операции new.
## Члены класса
Данные и функции, объявленные внутри класса, называются членами класса. Наряду с членами классы могут содержать вложенные типы (классы).

## Данные-члены
Данные-члены – это поля, константы, события. Они могут быть как статическими (ассоциированными с классом), так и относящимися к конкретному объекту (объект содержит собственную копию данных).

Поля – это любые переменные, ассоциированные с классом или его экземпляром  (объектом).

Константа, объявленная в классе со словом const, также ассоциирована с классом. Константа рассматривается как переменная, значение которой не может быть изменено. Но если возникает необходимость в переменной, значение которой до начала выполнения программы не известно, а в ходе выполнения программы не должно изменяться, то вместо константы следует использовать поле, предназначенное только для чтения. Такое поле объявляется с ключевым словом readonly. Правило использования таких полей утверждает, что значения им можно присваивать только в конструкторе. В отличие от константного поля поле readonly может принадлежать экземпляру, поэтому если необходимо ассоциировать его с классом, то следует явно определить его статическим. 

Событие позволяет определить, предусмотрена ли обработка события конкретным объектом, и задать метод, обрабатывающий событие.

## Функции-члены
Функции-члены обеспечивают функциональность класса. Они включают методы, свойства, конструкторы, финализаторы, операции и индексы.

### Методы
Методы – это функции, ассоциированные с определенным классом, они могут быть либо методами экземпляра, либо статическими методами, которые реализуют общую для класса функциональность, не требующую создания объекта. Синтаксис объявления методов практически совпадает с синтаксисом объявления компонентных функций в С++, отличия состоят в том, что: 
1) спецификатор доступа должен быть указан у каждого метода (блочное определение прав доступа не допускается); 
2) все методы объявляются и реализуются внутри определения класса. Синтаксис вызова методов полностью совпадает с С++.

Параметры могут передаваться в метод либо по значению, либо по ссылке. По умолчанию в С# все параметры передаются по значению, т.е. значения фактических параметров после выполнения метода не изменяются, однако следует проявлять осторожность при передаче в метод параметров ссылочного типа, таких как объект или массив. Исключение составляют строки, хотя и относятся к ссылочным типам. При изменении строки внутри метода в памяти создается новая строка, поэтому исходная строка не изменяется. Для передачи параметра по ссылке необходимо перед ним поместить ключевое слово ref. Это же слово следует записать и перед соответствующим фактическим параметром при вызове метода. И, наконец, любой фактический параметр должен быть инициализирован прежде, чем он будет передан в метод. Однако это ограничение не действует в отношении так называемых выходных параметров. Выходные параметры выделяются ключевым словом out и передаются также по ссылке, out записывается как при определении, так и при вызове метода.

С# поддерживает перегрузку методов, т.е. может существовать несколько вариантов метода, отличающихся типом и/или количеством параметров, при перегрузке метода недостаточно, чтобы варианты отличались только типом возвращаемого результата и/или спецификацией параметров ref и out. 

С# не поддерживает параметры со значениями по умолчанию.

### Перекрытие методов
Виртуальные методы в производном классе перекрываются с модификатором override, при перекрытии обычного метода базового класса в производном классе следует добавить ключевое слово new. Для вызова в производном классе метода базового класса используется следующий синтаксис: base.имя_метода().

### Свойства
Свойства – это наборы функций, определяющие правила доступа к private полям класса.
Чтобы определить свойство, используется следующий синтаксис:
```
public тип_свойства имя_свойства
{
   get
     {
        return имя_поля;
     }
   set
     {
        // код для установки значения поля
        имя_поля = value;
     }
}
```

Функция get не принимает никаких параметров и возвращает значение того типа, который объявлен для свойства. Для set также не указывается никаких параметров, по умолчанию эта функция имеет один параметр value того же типа, что и свойство. Можно создать свойство, доступное только для чтения или только для записи, для этого достаточно в определении свойства указать только одну функцию. По умолчанию функции получают статус доступа, определенный для свойства, однако допускается применение своего спецификатора доступа для одной из функций get или  set (но хотя бы одна должна иметь статус доступа по умолчанию).

Функции, обеспечивающие доступ к полям объекта, обычно рассматриваются компилятором как встраиваемые (аналог inline в С++), поэтому наличие множества маленьких функций не приводит к снижению эффективности программы в целом.

Свойства, как и методы, могут быть перегружены в производных классах. Для свойств также могут задаваться модификаторы virtual, override или abstract, которые записываются после статуса доступа.

### Конструкторы
Конструкторы  - это специальные функции, вызываемые автоматически при создании объекта. Имя конструктора совпадает с именем класса. Конструктор не возвращает никакого результата, используется для инициализации полей объекта. Если конструктор в классе не определен, то он будет создан компилятором автоматически. Такой конструктор будет инициализировать поля объекта нулевыми значениями: null для ссылочных типов, 0 для числовых, false для логических. C# допускает перегрузку конструкторов, однако если в классе определен хотя бы один конструктор, компилятор конструктор по умолчанию не генерирует.

Обычно конструктор имеет статус доступа public, однако конструктор можно определить как личный (private) или защищенный (protected), однако такой конструктор не позволяет создавать экземпляры классов в привычном их понимании.


С# позволяет определять статические конструкторы без параметров. Статический конструктор выполняется лишь однажды. Причиной для написания статического конструктора может быть наличие в классе статических полей или свойств, которые должны быть инициализированы до создания экземпляра данного класса. Вызов статических конструкторов осуществляется автоматически, предсказать, в каком порядке будут выполняться статические конструкторы различных классов, практически невозможно, однако гарантировано, что статический конструктор будет вызван только один раз и наиболее вероятно непосредственно перед первым вызовом любого члена класса. Статический конструктор не может иметь спецификатора доступа и никогда не вызывается никаким другим кодом C#, поэтому он не имеет параметров. У каждого класса может быть только один статический конструктор, который может иметь доступ только к статическим членам класса.

Наряду со статическим конструктором допускается определять конструктор без параметров, система различает такие конструкторы по спецификатору static.

Для вызова одного конструктора из другого  в C# предусмотрен специальный синтаксис, известный как  инициализатор конструктора:
```
public имя_класса([список_параметров]) : this ([список_параметров])
{
  // операторы конструктора
}
```

Ключевое слово this означает вызов подходящего по сигнатуре конструктора этого же класса. Если требуется вызвать конструктор базового класса, то слово this заменяется на слово base. Инициализатор может содержать только один вызов конструктора.

### Финализаторы
Финализаторы – специальные функции, вызываются для удаления объекта из памяти, когда CLR (среда выполнения .NET – Common Language Runtime) определяет, что объект больше не нужен. По сути финализатор – это аналог деструктора в С++, имеет то же имя, что и класс,  но имени класса предшествует символ «тильда» (~). Поскольку CLR выполняет сборку мусора автоматически, то невозможно предсказать, когда будет вызван финализатор.

### Операции
Операции позволяют определить способ выполнения предопределенных операций применительно к объектам собственных классов (перегрузка операций).

### Индексы
Индексы позволяют индексировать объекты подобно элементам массива или коллекции.

### Частичные классы
Ключевое слово partial позволяет определить класс, структуру или интерфейс, распределенный по нескольким файлам, слово partial записывается непосредственно перед словом class. При компиляции все части собираются компилятором в единый тип.

### Статические классы
Если класс не содержит ничего, кроме статических методов и свойств, этот класс может быть определен как статический с помощью слова static перед словом class. Определение статического класса гарантирует, что к этому классу не будут добавлены нестатические члены и никогда не будут созданы экземпляры этого класса. Для вызова методов статического класса используется имя типа.

### Абстрактные классы и методы
Абстрактные функции объявляются с помощью ключевого слова abstract, которое записывается сразу после спецификатора доступа. Абстрактная функция автоматически является виртуальной без дополнительных инструкций и должна быть перекрыта в производном классе. Класс, содержащий абстрактную функцию, также является абстрактным и должен быть таковым объявлен с помощью слова abstract.

### Закрытые классы и методы
Закрытые классы и методы объявляются с помощью ключевого слова sealed. От закрытого класса нельзя наследовать, т.е. от него нельзя создать производный класс. Закрытый метод нельзя переопределить в производном классе.

### Структуры
